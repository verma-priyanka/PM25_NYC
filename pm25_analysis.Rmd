---
title: "Advanced Raster Final Project <br> Monitoring Trends in PM2.5 in NYC"
author: "Jordan Frey, Priyanka Verma"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
  theme: architect
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Introduction
For our final project, we have decided to analyze air pollution trends in the New York Metropolitan Area. Specifically, we have decided to focus on particulate matter 2.5 (PM2.5) due to its pervasiveness and widespread impact on the respiratory health of residents. Our data has been provided by the Environmental Protection Agency (EPA).


## Libraries
```{r warning=FALSE, include=TRUE, message=FALSE}
library(sf)
library(tidyverse)
library(raster)
library(gstat)
library(lubridate)
library(plyr)
library(tmap)
library(rasterVis)
library(RColorBrewer)
library(reshape)
library(Kendall)
library(EcoGenetics)
library(imager)
```

## Data
The Data comes from the United States Environmental Protection Agency for a 10-year period from 2010-2020. Since we are only interested in the PM2.5 measure for the winter months, we add a filter to extract dates between December and March. 

```{r warning = FALSE, message = FALSE}
# Reads all csv files in this directory
data = list.files(path="data", pattern="*.csv", full.names=TRUE)
# Merges all csv files into a single dataframe for analysis
data_all = ldply(data, read_csv)
# replace spaces in column names with '_'
names(data_all) <- gsub(" ", "_", names(data_all))
# rename latitude & longitude columns
names(data_all)[names(data_all) == "SITE_LONGITUDE"] <- "x"
names(data_all)[names(data_all) == "SITE_LATITUDE"] <- "y"
# Convert to date format for filtering
data_all$Date <- data_all$Date %>% as.Date("%m/%d/%Y")
# extract year from Date as a new column for yearly interpolation
data_all[, "year"] <- format(data_all[,"Date"], "%Y")
# filter for winter months
df_winter <- data_all %>% 
  filter(strftime(data_all$Date, "%m") %in% c('12','01','02','03'))
```

## Spatial Conversion
The shapefile for the New York Core-based Statitical Area (CBSA) came from the U.S. Census Bureau and consist of counties in and around the New York City urban area. Counties in upstate New York, Long Island as well as surrounding states of New Jersey are also included. 
```{r fig.align='center'}
# read in cbsa shapefile
nycbsa <- st_read("data/ny_cbsa.shp")

# convert sites to an sf object using projection from cbsa
epa_sites <- df_winter %>% 
  distinct(Site_ID, x, y) %>% 
  st_as_sf(coords = c("x", "y"), crs = st_crs(nycbsa))
```

## Explore Metropolitan Area & Air Pollution Monitoring Sites
The monitoring site that falls outside the metro area boundary and will be removed from the analysis
```{r warning = FALSE, message = FALSE, fig.align='center'}
tmap_mode("view")

tm_shape(nycbsa, name = "NY Metropolitan Area", is.master = TRUE) + 
  tm_borders(col= "coral") +
  tm_layout(title = "New York Metro Area Air Pollution Monitoring Sites") +
  tm_shape(epa_sites, name = "EPA Air Monitoring Sites") +
  tm_dots(col="red")
```

## Rasterize
Rasterize the nycbsa shapefile for interpolation surface
```{r fig.align='center', fig.height=4, fig.width=4}
# create a raster file with resolution of 0.01 for ny metro area
target <- raster(x = extent(nycbsa), crs = crs(nycbsa), res = 0.01)
# assign value of 1 to each pixel
values(target) <- 1
# crop raster surface to NY metro region
nycbsar <- nycbsa %>% rasterize(x = ., y = target, field = "GEOID")
# plot for visual check
par(mar = c(1, 0, 0, 4))
plot(nycbsar, axes = FALSE, box = FALSE, legend = FALSE)
```

## Interpolation
```{r, warning = FALSE, message = FALSE}
# assign year to winter months
# if jan-march, assign to previous year, else assign same year
df_winter$winter <- ifelse(format(df_winter$Date, "%m") == "12",
                           df_winter$year,as.numeric(df_winter$year)-1)
# create a list of all winter years
years <- unique(df_winter$winter)

# Interpolate for each winter season
# Calculate mean for every site for each winter season
# int_df.list: List of dataframes with mean PM2.5 for each winter
# invdist.list List of interpolated surfaces for each winter
int_df.list =list()
invdist.list = list()
for (each_year in years){
  # calculate mean for every site for each winter season
  int_df <- df_winter %>% 
  filter(winter == each_year) %>% 
  group_by(Site_ID, winter, x, y) %>%
  summarise_at(vars(Daily_Mean_PM2.5_Concentration),
               list(PM_Mean = mean))
  # add dataframe to list
  int_df.list[[each_year]] = int_df
  
  # inverse distance interpolation for each year
  # create a gstat object
  invdist <- gstat(id = "PM_Mean",
                   formula = PM_Mean ~ 1,
                   locations = ~x + y,
                   data = int_df)
  # generate interpolated layer
  invdistr <- interpolate(object = nycbsar, model = invdist)
  # mask to metro area
  invdistrmsk <- mask(x = invdistr, mask = nycbsa)
  # add interpolated layer to list
  invdist.list[[each_year]] = invdistrmsk
}
```

# Plotting Interpolated Layer 
```{r warning = FALSE, message = FALSE, fig.align='center'}
# create a stack for all interpolated layers for plotting
s <- raster::stack(invdist.list)
# edit name for each layer
names(s) <-  gsub(x = names(s), pattern = "X", replacement = "Winter")
# set up theme for plot
mapTheme <- rasterTheme(region=brewer.pal(8,"Blues"), rev=TRUE)
# plot interpolated layers
levelplot(s, pretty = TRUE,  main="NY Metropolitan Area PM2.5 Mean", par.settings=mapTheme)
```

# Saving Interpolated Raster Images as .RST
```{r warning = FALSE, message = FALSE, fig.align='center', eval=FALSE}
for (i in 1:length(s@layers)){
  writeRaster(s[[i]], filename = paste0("terrset/", names(s[[i]]), ".rst"),
              overwrite = F)
}
```

```{r}
# # Interactive map for interpolated layers
# # The legend is currently messed up

# tmap_mode("view")
# tm_shape(s) +
#   tm_raster(palette = "-magma", alpha = 0.5)+
#   tm_facets(as.layers = TRUE) +
#   tm_layout(title = "NY Metropolitan Area PM2.5 Mean", 
#             legend.outside.position = "left", legend.outside = TRUE)
```

# Histogram
```{r fig.align='center'}
# raster stack to df for each x, y
# remove NA values
stack_df <- as.data.frame(s, xy = TRUE, na.rm = TRUE)%>%
  melt(id.vars = c('x','y'))

# histogram for interpolated layers
par(mfrow=c(4,2))
ggplot(stack_df) +
  geom_histogram(aes(value), binwidth = .5) +
    facet_wrap(~variable)
```

# Mann-Kendall Trend Test
```{r message=FALSE, warning=FALSE, include=FALSE, results="hide"}
# function for Mann-Kendall trend test
kendall = function(x){return(unlist(MannKendall(x)))}
# apply function to raster stack. RUN THIS CHUNK IN CONSOLE ONLY- takes too long in markdown
# ...and ignore "WARNING: Error exit, tauk2. IFAULT =  10" warning. Output has been validated in TerrSet, and this message appears to be a bug in the package.
kendall_output = calc(s,kendall)
```

# Kendall's tau & p-value 
```{r fig.align='center'}
# plot Kendall's tau statistic
plot(kendall_output$tau, main = "Kendall's tau statistic")
# plot p-value
plot(kendall_output$sl, main = "p-value")

# write to rst
writeRaster(kendall_output$tau, filename = "tau.rst", overwrite=TRUE)
writeRaster(kendall_output$sl, filename ="mk_p-value.rst", overwrite=TRUE)

```

# TerrSet Validation: Kendall Tau & P-Value
```{r fig.align='center'}
ktau_img <- load.image("terrset/TERRSET_MK_TAU.BMP")
plot(ktau_img)

```

```{r fig.align='center'}

mkp_img <- load.image("terrset/TERRSET_MK_P.BMP")
plot(mkp_img)

```

# Theil-Sen Median Trend Test
```{r fig.align='center', eval=FALSE}

#saves two images automatically to working directory: pvalue, and slope of theil-sen
eco.theilsen(s, dates = c(seq(from = 2009, by = 1, to = 2019)))
file.rename(from = "pvalue.tif", to = "theilsen_pvalue.tif")
file.rename(from = "slope.tif", to = "theilsen_slope.tif")

```

```{r fig.align = 'center'}
theilsen_slope <- raster("theilsen_slope.tif")

# write slope image to IDRISI raster format for easy comparison
writeRaster(theilsen_slope, filename = "theilsen_slope.rst", overwrite=T)
```


#TerrSet Validation: Theil-Sen Median Trend
```{r fig.align='center'}

theilsen_slope_img <- load.image("terrset/TERRSET_THEILSEN_SLOPE.BMP")
plot(theilsen_slope_img)

```






